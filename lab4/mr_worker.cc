#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <mutex>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <assert.h>
#include <algorithm>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal {
    string key;
    string val;
};

bool isLowerLetter(char ch) {
    return 'a' <= ch && ch <= 'z';
};
bool isUpperLetter(char ch) {
    return 'A' <= ch && ch <= 'Z';
};
bool isEngAlpha(char ch) {
    return isLowerLetter(ch) || isUpperLetter(ch);
};

bool judgeStr(string& str) {
    if (str == "") return false;
    int size = str.size();
    for (int i = 0; i < size; i++)
        if (!isEngAlpha(str[i])) return false;
    return true;
};
string strPlus(string str1, string str2) {
    return to_string(stol(str1) + stol(str2));
};

int scanDir(string base, vector<string> &ret) {
    DIR * dir = opendir(base.c_str());
    struct dirent * rent;
    char s[100];
    while (rent = readdir(dir)) {
        strcpy(s, rent->d_name);
        if (s[0] != '.')
            ret.push_back(s);
    }
    closedir(dir);
    return ret.size();
}

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector <KeyVal> Map(const string &filename, const string &content) {
    vector<KeyVal> ret;
    int l = 0, r = 0;
    while (content[r] != '\0') {
        if (isEngAlpha(content[r])) r++;
        else {
            string str = r > l ? content.substr(l, r - l) : "";
            if (judgeStr(str)) {
                KeyVal kv;
                kv.key = str; kv.val = "1";
                ret.push_back(kv);
            };
            while (content[r] != '\0' && !isEngAlpha(content[r])) r++;
            l = r;
        };
    };
    string str = r > l ? content.substr(l, r - l) : "";
    if (judgeStr(str)) {
        KeyVal kv;
        kv.key = str; kv.val = "1";
        ret.push_back(kv);
    };
    return ret;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector <string> &values) {
    string ret = "0";
    int size = values.size();
    for (int i = 0; i < size; i++)
        ret = strPlus(ret, values[i]);
    return ret;
}

typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

//
// The Map part of your workers can use a hash function to 
// distribute the intermediate key-values to different files
// intended for different Reduce tasks.
//
int strHash(const string &str) {
    unsigned int hashVal = 0;
    for (char ch : str)
        hashVal = hashVal * 131 + (int) ch;
    return hashVal % REDUCER_COUNT;  // one reducer is responsible for this particular key
}

class Worker {
public:
    Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

    void doWork();

private:
    void doMap(int index, const string &filename);
    void doReduce(int index, int nfiles);
    void doSubmit(mr_tasktype taskType, int index);

    void askTask(mr_protocol::AskTaskResponse &res);

    mutex mtx;
    int id;

    bool working = false;  // current process is working or not

    rpcc *cl;
    std::string basedir;
    MAPF mapf;
    REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::askTask(mr_protocol::AskTaskResponse &res) {
    mr_protocol::status ret = cl->call(mr_protocol::asktask, id, res);
    VERIFY (ret == mr_protocol::OK);
}

void Worker::doMap(int index, const string &filename)
{
	working = true;
    string intermediatePrefix;
    intermediatePrefix = basedir + "mr-" + to_string(index) + "-";
    string content;
    getline(ifstream(filename), content, '\0');

    vector <KeyVal> keyVals = Map(filename, content);

    vector <string> contents(REDUCER_COUNT);
    for (const KeyVal &keyVal : keyVals) {
        int reducerId = strHash(keyVal.key);
        contents[reducerId] += keyVal.key + ':' + keyVal.val + ':';
    }

    for (int i = 0; i < REDUCER_COUNT; ++i) {
        const string &content = contents[i];
        if (!content.empty()) {
            string intermediateFilepath = intermediatePrefix + to_string(i);
            ofstream file(intermediateFilepath, ios::out);
            file << content;
            file.close();
        }
    }
}

void Worker::doReduce(int index, int nfiles) {
    working = true;
    vector<string> filenames;
    if (scanDir(basedir, filenames) <= 0) {
        printf("Reduce workers: no intermediate files\n");
        return;
    }

    vector<KeyVal> KVA;
    for (const string filename: filenames) {
        int mapId, reduceId;
        sscanf(filename.c_str(), "mr-%d-%d", &mapId, &reduceId);
        char mapIdFirst = filename[3];
        if (reduceId == index && mapIdFirst >= '0' && mapIdFirst <= '9') {
            string full_path = basedir + filename;
            string content;
            ifstream in(full_path);
            getline(in, content, '\0');
            in.close();

            while (content.length() > 0) {
                // parse the intermediate file produced by map workers
                size_t pos = content.find(":");
                KeyVal kv;
                kv.key = content.substr(0, pos);
                content.erase(0, pos + 1);
                pos = content.find(":");
                kv.val = content.substr(0, pos);
                content.erase(0, pos + 1);

                KVA.push_back(kv);
            }
        }
    }

    sort(KVA.begin(), KVA.end(),
    [](KeyVal const & a, KeyVal const & b) {
        return a.key < b.key;
	});

    string output_content;
    string mr_out = basedir + "mr-out-" + to_string(index);
    ofstream out(mr_out);
    for (int i = 0; i < KVA.size(); ) {
        int j = i + 1;
        for ( ; j < KVA.size() && KVA[j].key == KVA[i].key; ) j++;
        vector <string> values;
        for (int k = i; k < j; k++)
            values.push_back(KVA[k].val);

        output_content.append(KVA[i].key).append(" ").append(Reduce(KVA[i].key, values)).append("\n");
        i = j;
    }

    out << output_content;
    out.close();
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{
	for (;;) {
        mr_protocol::AskTaskResponse res;
        askTask(res);
        switch (res.tasktype) {
            case MAP:
                doMap(res.index, res.filename);
                doSubmit(MAP, res.index);
                break;
            case REDUCE:
                doReduce(res.index, res.nfiles);
                doSubmit(REDUCE, res.index);
                break;
            case NONE:
                sleep(1);
                break;
            default:
                printf("Workers: unknown task type: %d\n", res.tasktype);
                break;
        }
	}
}

int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
        exit(1);
    }

    MAPF mf = Map;
    REDUCEF rf = Reduce;

    Worker w(argv[1], argv[2], mf, rf);
    w.doWork();

    return 0;
}
